# 5 Requisitos de Back-end de Alta Prioridade para o Nobre Hub (v3.0)

Com base na análise do **Relatório de UI/UX** e na documentação técnica original (`PROJECT_DOC_COMPLETE.md`), os seguintes 5 requisitos de back-end são considerados de **alta prioridade** para suportar as funcionalidades avançadas e a experiência de usuário proposta.

| Prioridade | Requisito de Back-end | Módulo Afetado | Dependência Crítica |
| :--- | :--- | :--- | :--- |
| **1** | **Real-time Message Ingestion e Broadcast (FIX)** | Inbox (ChatView.tsx) | Correção do Socket.io, Redis (para escalabilidade) |
| **2** | **Endpoint Unificado de Visão 360º** | Kanban (LeadDetailModal.tsx) | Modelos v3.0: Lead, AuditLog, Activity |
| **3** | **Motor de Execução de Playbooks (Worker)** | Automações (FlowBuilder.tsx) | Modelos v3.0: AutomationFlow, Activity, Redis Queue |
| **4** | **Serviço de Mídia e Transcrição IA** | Chat (Message) | Object Storage (S3/Supabase), OpenAI API (Whisper) |
| **5** | **API Transacional de Mudança de Etapa** | Kanban (Drag-and-Drop) | Modelos v3.0: PipelineStage, AuditLog |

---

## Detalhamento dos Requisitos

### 1. Real-time Message Ingestion e Broadcast (FIX)

O requisito mais urgente é a correção do problema de real-time para mensagens recebidas, conforme identificado no `PROJECT_DOC_COMPLETE.md` ("Socket.io não funciona para incoming").

*   **Objetivo:** Garantir que o agente veja a mensagem do cliente no `ChatView.tsx` em tempo real (milissegundos).
*   **Ação de Back-end:** O endpoint `/whatsapp/webhook` deve ser reestruturado para:
    1.  Processar o webhook do 360Dialog.
    2.  Salvar a nova `Message` no banco de dados.
    3.  Emitir um evento de Socket.io (`new_message`) contendo o objeto da mensagem e o `conversationId`.
    4.  **Recomendação:** Implementar o Redis como *Socket.io Adapter* para garantir que o broadcast funcione mesmo se o back-end escalar para múltiplos processos/instâncias.

### 2. Endpoint Unificado de Visão 360º

A interface exige que o `LeadDetailModal.tsx` exiba todos os dados relacionados em uma única visão (Visão 360º).

*   **Objetivo:** Reduzir o número de requisições HTTP do frontend para carregar o modal de detalhes do lead.
*   **Ação de Back-end:** Criar um novo endpoint (ex: `GET /leads/:id/details`) que retorne um objeto aninhado contendo:
    *   Dados do `Lead` (incluindo `LeadSourceData`).
    *   Lista de `Conversation` e últimas 5 `Message`.
    *   Lista de `AuditLog` (Linha do Tempo).
    *   Lista de `Activity` pendentes (Playbook/Tarefas).
*   **Benefício:** Melhora a performance do frontend e simplifica a lógica de carregamento de dados.

### 3. Motor de Execução de Playbooks (Worker)

A funcionalidade de Playbooks (Automações) é assíncrona e exige processamento fora do ciclo de requisição HTTP.

*   **Objetivo:** Executar a lógica condicional e as ações definidas no `AutomationFlow.flowDefinition` (JSON) de forma confiável.
*   **Ação de Back-end:**
    1.  Criar um serviço de *Worker* (usando BullMQ/Agenda.js e Redis) que rode em um processo separado.
    2.  Criar um endpoint (ex: `POST /triggers/stage-change`) que, ao ser chamado, enfileira uma tarefa para o *Worker*.
    3.  O *Worker* deve: Ler o `AutomationFlow` associado ao `PipelineStage` e executar as ações (ex: criar `Activity`, enviar template, mover lead).
*   **Recomendação:** O *Worker* deve ser resiliente a falhas e ter um sistema de *retry* (tentativa de reexecução).

### 4. Serviço de Mídia e Transcrição IA

O UI/UX exige a transcrição de áudios do WhatsApp para texto no `ChatView.tsx`.

*   **Objetivo:** Processar mídias recebidas e usar IA para extrair o texto.
*   **Ação de Back-end:**
    1.  O `POST /whatsapp/webhook` deve identificar mensagens de áudio.
    2.  Baixar o arquivo de áudio e fazer o upload para o **Object Storage** (armazenando o `mediaUrl` no `Message`).
    3.  Enfileirar uma tarefa para o *Worker* (Requisito #3).
    4.  O *Worker* deve: Chamar a API **OpenAI Whisper** com o arquivo de áudio e, ao receber a transcrição, atualizar o campo `Message.text` e emitir um evento de Socket.io para o frontend.

### 5. API Transacional de Mudança de Etapa

O *drag-and-drop* no Kanban é uma ação crítica que exige atomicidade e deve ser o gatilho para a automação.

*   **Objetivo:** Garantir que a mudança de etapa seja uma transação única que atualiza o `Lead` e registra a auditoria, disparando o Playbook.
*   **Ação de Back-end:** Criar um endpoint (ex: `PATCH /leads/:id/stage`) que:
    1.  Verifica a permissão do usuário.
    2.  Executa uma **transação de banco de dados** que:
        *   Atualiza o `Lead.pipelineStageId`.
        *   Cria um novo registro no `AuditLog` (ação: `stage_change`).
    3.  Chama o **Motor de Execução de Playbooks** (Requisito #3) para processar as automações.
*   **Benefício:** Garante a integridade dos dados e a execução imediata das automações de funil.
